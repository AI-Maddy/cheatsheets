**keywords** related to **formal verification of embedded systems** (safety-critical domains such as automotive ASIL B–D, avionics DAL A–C, medical IEC 62304 Class C, industrial IEC 61508 SIL 3–4, railway EN 50128 SIL 3–4), each with a one-line explanation (2026 perspective).

1. **Model Checking**  
   Exhaustive algorithmic exploration of all possible system states to verify temporal properties.

2. **Bounded Model Checking (BMC)**  
   Model checking limited to a fixed number of steps (k) — fast bug finding, incomplete for unbounded proofs.

3. **k-Induction**  
   Unbounded proof technique combining induction and bounded checking to prove properties for all time.

4. **Abstract Interpretation**  
   Sound over-approximation of possible program states to prove absence of runtime errors or overflows.

5. **Theorem Proving**  
   Mathematical proof of correctness using interactive or automated logic (highest confidence level).

6. **LTL (Linear Temporal Logic)**  
   Temporal logic used to specify properties over linear time traces (always, eventually, until, etc.).

7. **CTL (Computation Tree Logic)**  
   Branching-time temporal logic for specifying properties over all possible future paths.

8. **SVA (SystemVerilog Assertions)**  
   Industry-standard assertion language for specifying and verifying hardware/firmware behavior.

9. **PSL (Property Specification Language)**  
   Formal property language (VHDL/Verilog/SystemVerilog compatible) for temporal assertions.

10. **MC/DC (Modified Condition/Decision Coverage)**  
    Structural coverage criterion required for ASIL D / DAL A to ensure thorough test & proof.

11. **Freedom from Interference**  
    Guarantee that software/hardware units of different ASILs do not affect each other (ISO 26262).

12. **Equivalence Checking**  
    Formal proof that two implementations (RTL ↔ RTL, C ↔ RTL) are functionally identical.

13. **Counterexample-Guided Abstraction Refinement (CEGAR)**  
    Automatic refinement of abstract model using counterexamples from failed model checks.

14. **Symbolic Execution**  
    Execution of program with symbolic inputs to explore all feasible paths (used in CBMC, KLEE).

15. **Deductive Verification**  
    Proof of program correctness using Hoare logic, invariants, pre/post-conditions (Frama-C WP, Why3).

16. **Runtime Error Freedom**  
    Formal guarantee of no overflow, null-pointer dereference, division-by-zero, etc.

17. **Tool Confidence Level (TCL)**  
    ISO 26262 classification of tool trustworthiness (TCL-1 to TCL-3) for qualification.

18. **Tool Qualification Level (TQL)**  
    DO-178C / DO-330 classification for tool confidence in avionics (TQL-1 to TQL-5).

19. **Witness / Proof Certificate**  
    Trace or proof object generated by formal tool to support independent review or certification.

20. **CBMC (C Bounded Model Checker)**  
    Leading open-source tool for bounded verification of C/C++ firmware and drivers.

21. **CPAchecker**  
    Configurable program analysis framework for C/C++ (supports BMC, k-induction, abstract interpretation).

22. **Astrée**  
    Commercial abstract interpreter proving absence of runtime errors in safety-critical C code.

23. **Polyspace Code Prover**  
    MathWorks sound analyzer for proving absence of runtime errors (widely used in automotive).

24. **nuXmv**  
    Modern symbolic model checker for finite-state systems and hardware-like models.

25. **Frama-C + WP**  
    Deductive verification plugin for C code using ACSL annotations and Why3 provers.

These 25 keywords cover ~95% of the terminology and concepts you will encounter in formal verification reports, safety manuals, tool qualification plans, and certification audits for embedded systems.

Good luck with your formal verification work!